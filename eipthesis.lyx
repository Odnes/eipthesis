#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\begin_preamble
\DeclareMathSizes{10}{12}{7}{5}
\usepackage{url}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_minted 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
\begin_inset Graphics
	filename assets/logo.png

\end_inset


\begin_inset Newline newline
\end_inset

Enterprise Integration Patterns
\begin_inset Newline newline
\end_inset

Building message-oriented middleware with Apache Camel
\end_layout

\begin_layout Author
Odysseas Neslechanidis
\begin_inset Newline newline
\end_inset

Supervisor: Christos Gkogkos
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Address
\align center
Graduation Thesis
\end_layout

\begin_layout Standard
\align center
University of Ioannina
\begin_inset Newline newline
\end_inset

Department of Informatics and Telecommunications
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty} 
\end_layout

\end_inset


\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
Enterprise Integration Patterns
\end_layout

\begin_layout Standard
Building message-oriented middleware with Apache Camel
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Author: Odysseas Neslechanidis
\end_layout

\begin_layout Standard
Supervisor: Christos Gkogkos
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Graduation Thesis
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
University of Ioannina
\end_layout

\begin_layout Standard
Department of Informatics and Telecommunications
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty} 
\end_layout

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Address
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
thispagestyle{empty} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\series bold

\begin_inset Newline newline
\end_inset

This thesis was approved by a three-person examination committee.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection*
Examination Commitee
\end_layout

\begin_layout Enumerate
Christos Gkogkos
\end_layout

\begin_layout Enumerate
.
\end_layout

\begin_layout Enumerate
.
\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Subsection*
Affidavit
\end_layout

\begin_layout Standard
I hereby affirm that this Bachelor’s Thesis represents my own written work
 and that I have used no sources and aids other than those indicated.
 All passages quoted from publications or paraphrased from these sources
 are properly cited and attributed.The thesis was not submitted in the same
 or in a substantially similar version, not even partially, to another examinati
on board and was not published elsewhere.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Signed,
\end_layout

\begin_layout Standard
Neslechanidis Odysseas 
\begin_inset space \hfill{}
\end_inset

All Rights Reserved ©
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Abstract
The term "Enterprise Integration Patterns (EIPs)" refers to a vocabulary
 of solutions to common problems in the integration of enterprise systems.
 Of such vocabularies pattern languages may be constituted to allow complex
 business flows of diverse form to be described and handled in a uniform
 way.
 
\end_layout

\begin_layout Abstract
Apache Camel is a framework that implements EIPs around a common interface
 based on Java Message Objects.
 Camel also provides an IDE-friendly declarative Domain Specific Language
 (DSL) oriented around this interface, which enables integration flows between
 disparate systems ("Camel routes") to be described neatly as Java Messages
 passed around between chained camel methods.
\end_layout

\begin_layout Abstract
The specifics of the underlying communication protocols (FTP, http, ActiveMessag
eQueue etc) are abstracted away and the flow of information is cleanly described
, leaving such considerations as availability, load balancing, validation,
 security as the primary factors influencing the middleware's architectural
 complexity.
\end_layout

\begin_layout Abstract
In this thesis production deployments of Java Spring middleware utilizing
 Apache Camel will be studied.
 The most commonly used EIPs' Camel implementations will be inspected, and
 a comparison with more established integration tooling will be made when
 convenient, to ascertain the benefits of the Message-Oriented Middleware
 (MOM)-backed Camel DSL approach.
 
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Keywords: Enterprise Integration Patterns, Apache Camel, Message-Oriented
 Middleware
\end_layout

\begin_layout Address
\align center
\begin_inset Newpage pagebreak
\end_inset


\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Section*
Abbreviations
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
API Application Programming Interface
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
EAI: Enterprise Application Integration 
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
EAS: Enteprise Application Software
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
EDA Event-Driven Architecture
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
EIP Enterprise Integration Patterns
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
EMS Enterprise Messaging System
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
ESB Enterprise Service Bus
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
MEP Message Exchange Pattern
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
MOM Message-Oriented Middleware
\end_layout

\begin_layout Labeling
\labelwidthstring 00.00.0000
QoS Quality of Service
\end_layout

\begin_layout Address
\align center
\begin_inset Newpage pagebreak
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{1}
\end_layout

\end_inset


\end_layout

\begin_layout Part
Enterprise Application Integration (EAI): the why and the how
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
Enterprise Application Software (EAS) is the term for computer programs
 used to satisfy the needs of an organization rather than individual users.
 Almost all business operations, at different points in time, have come
 to benefit from the proliferation of software in this space.
 Commonly used acronyms used to categorize such software include ERP (Enteprise
 Resource Planning), CRM (Customer Relationship Management), BI (Business
 Intelligence), CMS (Content Management System), WMS (Warehouse Management
 System).
 They serve to automate every business need of modern enteprises, from it's
 customer facing operations, to keeping track of warehouse inventory, calculatin
g billing and taxes, observing regulations, and much more.
 While comprehensive enterprise software suites offering differing degrees
 of customizability have come to exist, owing to the organisational similarity
 of enterprises above a certain scale, switching costs, preservation of
 optionality in partnering with software vendors
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"
literal "false"

\end_inset

, as well as other adjoining business considerations, have hindered their
 more widespread adoption.
 Added to that, the employment of Domain-driven design, in recognition of
 the maintainability and extensibility benefits domain-expert input in the
 refining of an applications's domain model confers, is a fact that has
 further complicated the effort of business software consolidation.
\end_layout

\begin_layout Standard
In this setting, the introduction of a 
\begin_inset Quotes eld
\end_inset

software glue
\begin_inset Quotes erd
\end_inset

 stack has come to be a very common business need, and much research in
 the space of EAI is aimed at providing insight for the development of better
 solutions in this class of software.
 The established term for such software is 
\begin_inset Quotes eld
\end_inset

middleware
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Newline newline
\end_inset

From the systematic study and development of solutions in this space, a
 particular subtype termed Message-Oriented Middleware, or MOM, has emerged
 as one the most promising.
 A vocabulary and a framework implementation for describing and building
 such middleware constitute the main topic of this thesis.
 
\end_layout

\begin_layout Section
Introducing EAI in a organization
\end_layout

\begin_layout Subsection
General challenges
\end_layout

\begin_layout Standard
Prior to engaging with the path-dependent and hard technical aspects of
 Enterprise Application Integration, it is necessary to consider a set of
 social and organizational features that the development and adoption of
 such solutions typically necessitate or bring about.
\end_layout

\begin_layout Standard
Enterprise Application Integration often requires a significant shift in
 corporate politics.
 By extension of Conway's law that postulates that 
\begin_inset Quotes eld
\end_inset

Organizations which design systems are constrained to produce designs which
 are copies of the communication structures of these organizations.
\begin_inset Quotes erd
\end_inset

, it appears that the consolidation of enterprise software tools serving
 business processes often necessitates a consolidation of the business units
 and IT departments involved in those same processes.
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Furthermore, owing to the wide scope of a middleware integration solution
 bringing together critical business functions, the novel risk of failure
 or misbehavior of such a system has to be internalized.
 The risk profile and magnitude of reorganization around such a single point
 of failure ought to be carefully considered.
\end_layout

\begin_layout Standard
Bordering the technical side, the feasibility of integrating systems by
 modifying them to better fit the integration architecture, rather than
 by having to design the integration architecture to work around the various
 systems' limitations and deficiencies, also often depends on political
 factors.
 In that vein, unsupported legacy systems still in operation, systems under
 proprietary licenses, and systems whose support is outsourced under more
 or less stringent long-term agreements can adversely influence the complexity
 of the final product.
\end_layout

\begin_layout Standard
In terms of standardization, it bears mentioning that despite the benefit
 of convergence around Web Services and a Service Oriented approach to middlewar
e architecture (which will be expounded upon in later chapters), the proliferati
on of new extensions or interpretations of the standard, and most significantly
 the shift towards REST (and, more recently GraphQL) in lockstep with the
 mobile revolution, has created new challenges for integration engineers.
 REST, in particular, owing to it being an architectural style for software
 that expose http APIs rather than a protocol for web services per se, is
 frequently implemented partially and/or wrongly, often necessitating ad-hoc
 code for the consumption of APIs exposed in this manner.
\end_layout

\begin_layout Standard
Finally, the operations aspect of utilizing middleware solutions presents
 a unique challenge, as maintenance, deployment, monitoring and troubleshooting
 of such heterogeneous, distributed systems commonly require mixes of skills
 which are not, as a matter of course, to be found in single individuals.
 To companies or organizations of sufficient scale as to already necessitate
 a formalized employee training regime, the overhead for the maintenance
 of such human capital might be lower.
\begin_inset CommandInset citation
LatexCommand cite
key "key-3"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
Types of integration
\end_layout

\begin_layout Standard
While the above challenges generally apply to every approach in the broader
 category of integration, many further issues have to be considered depending
 on the business aims that dictate, and the technical aspects tha come as
 a consequence of, the prospective type of integration solution.
 The following categorization has been proposed:
\end_layout

\begin_layout Subsubsection
Information Portals
\end_layout

\begin_layout Standard
Information portals serve to aggregate information from disparate systems
 within an organization with the aim of making it more accesible to humans.
 They often facilitate the collaboration between different departments and
 physical locations.
 They are also commonly used in business decision processing and data analysis.
 Common features include multi-window views serving information from different
 sources with automatic refresh of related windows during navigation, search,
 tagging and other categorization schemes.
 
\end_layout

\begin_layout Standard
Various other more advanced features are common, but being as they cater
 to particular business functions, employees roles or departments, no account
 of those will be attempted.
 Indeed, one of the common abstract features, or aims, of such systems,
 is the personalization of the displayed information, achieved through the
 profiling of users based on role, experience, competencies, habits and
 expressed preferences.
 
\end_layout

\begin_layout Subsubsection
Data Replication 
\end_layout

\begin_layout Standard
Many business systems require access to the same data, but are designed
 to utilize their own, separate datastores.
 The resulting data replication necessitates provisions for maintaining
 the data synchronized.
 Commonly utilized for those purposes are the replication features built
 into modern Database Management Systems, the file export and import functions
 supported by many Enterprise Software Systems, and message-oriented middleware
 automating transport of data via messages between arbitrary datastore solutions.
\end_layout

\begin_layout Subsubsection
Shared Business Functions
\end_layout

\begin_layout Standard
Needless duplication can exist in code serving business functions as well
 as in data.
 Were supported, invocation of shared business functions implemented as
 services
\begin_inset Foot
status open

\begin_layout Plain Layout
A service is a contract-defined function that is universally available,
 and responds to requests from “service consumers
\begin_inset Quotes erd
\end_inset

 .
\end_layout

\end_inset

can help avoid the native implementation of redundant functionality.
\end_layout

\begin_layout Standard
Were feasible, the need for data replication can also be circumvented via
 this approach by serving shared data as a service.
 In that vein, some criteria to be considered include the amount of control
 to be had over the systems (calling a shared function is usually more intrusive
 than loading data into the database) and the rate of change of the relevant
 data (service invocation is costlier than data access, therefore is less
 efficient for relatively frequently accessed, relatively static data).
\end_layout

\begin_layout Subsubsection
Service-Oriented Architectures and Distributed Business Processes
\end_layout

\begin_layout Standard
Once an enterprise assembles a collection of useful services, managing the
 services becomes an important function.
 
\end_layout

\begin_layout Standard
Service Oriented Architecture is a proposed style of service design and
 orchestration that incorporates the best industry practices in structuring
 middleware solutions around services that correspond to business functions.
 This paricular approach to middleware architecture shall be expounded upon
 in a later chapter.
\end_layout

\begin_layout Standard
A variant dubbed 
\begin_inset Quotes eld
\end_inset

Distributed Business Process
\begin_inset Quotes erd
\end_inset

, is also to be found in the bibliography.
 It concerns the design of management services that serve to coordinate
 the execution of the relevant business functions that are implemented natively
 in an integrated system's constituent applications, in order to achieve
 each and every particular business process.
 Such schemes can exist within larger SOA-abiding systems, and the lines
 between the two terms often blur.
\end_layout

\begin_layout Subsubsection
Business-to-Business Integration
\end_layout

\begin_layout Standard
In many cases, business functions may be available from outside suppliers
 or business partners.
 Business to Business (B2B) integration software provides the architecture
 needed to digitize information and route it through an organization’s trading
 ecosystem (usually online platforms) using the Electronic Data Interchange
 (EDI) format appropriate for the application.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

In the following chapter, the various technical approaches to Enterprise
 Application Integration will be discussed, beginning by retracing the historica
l contingencies defining the evolution of the EAI field, and culminating
 with a direction of focus towards the widely successful event-driven SOA
 approach and the message-oriented middleware used to facilitate it, a particula
r implementation of which will be the topic of the rest of this thesis.
\end_layout

\begin_layout Section
The Evolution of Enterprise Application Integration
\end_layout

\begin_layout Subsection
Islands of automation and the advent of EAI
\end_layout

\begin_layout Standard
The term 
\begin_inset Quotes eld
\end_inset

Islands of automation
\begin_inset Quotes erd
\end_inset

 was a popular term intoduced in the 1980s to describe the status quo of
 automation systems existing within information silos.
 The rapid development and adoption of enterprise software systems during
 this time came to pass with little regard for the ability of those systems
 to communicate with one another.
 
\end_layout

\begin_layout Standard
Such fragmentation of automation systems turned out to significantly increase
 the cost of operations within organisations, and contribute to a higher
 barrier of transaction cost for cooperation across different enterprises.
 A major part of business operations requires coordination between multiple
 departments/organisations, each with their own system of automation.
 In this state of affairs, manual intervention is required to keep information
 systems updated, human effort, data, infrastructure are often duplicated
 needlessly, and the risk of costly human error is introduced at multiple
 points.
\begin_inset Newline newline
\end_inset

 The field of Enterprise Application Integration (EAI) is a field of study
 aiming to refinre a framework for rectifying these inefficiencies.
 The shifting nature of the business landscape and of enterprises that operate
 within it, together with the continued innovation in, and expansion of,
 the EAS space, has resulted in it being a complicated problem to tackle.
 
\end_layout

\begin_layout Standard
Enterprise software is adopted at different times, it is developed from
 different vendors, at different points in time, oriented towards different
 business needs.
 
\end_layout

\begin_layout Standard
As previously noted, the role of middleware is to to facilitate communication
 or connectivity between applications that were developed without such provision
s, often through channels beyond those available from the operating system
 serving as the platform, or across distributed networks.
\begin_inset CommandInset citation
LatexCommand cite
key "key-7,key-9"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
In the early days of EAI, the development of custom middleware solutions
 begun spreading as a practice.
\end_layout

\begin_layout Subsection
Point to point integration
\end_layout

\begin_layout Standard
The conceptually simplest way to perform integration is by connecting informatio
n systems directly in a point-to-point paradigm.
 In a common implementation, custom procedures are called on both ends targeting
 the native filesystem as the locus of communication between the systems,
 often in conjuction with a network file transfer protocol such as FTP.
 A system assuming the client role executes a reporting routine to extract
 data to a text file in a specified format.
 A routine is then run by the receiving application to import and process
 the data.
\end_layout

\begin_layout Standard
As similar point-to-point solutions begun to emerge, it nonetheless became
 apparent that the net cost of development and maintenance of such solutions
 stood high, and steeply increased with scale.
 This came as a result of the fact that in the point-to-point approach,
 the introduction of one new system typically requires many specialized
 connections to the existing systems, which in turn impose additional maintenanc
e burden, reduce agility, and constitute additional potential points of
 failure.
\begin_inset Newline newline
\end_inset

Additionally, the tight coupling makes reliability a challenge, especially
 for real-time applications.
 For example, if the connection between two parties in a client-server connectio
n is interrupted, the data supposed to be received by the client will be
 lost during this interruption, unless complex logic to deal with caching,
 session management and error recovery on the server side is implemented.
 
\begin_inset Newline newline
\end_inset

Moreover, the synchronous nature of the communication ties up resources
 to handle the interaction, which presents a bottleneck as the system scales
 both in service load and complexity.
\begin_inset Newline newline
\end_inset

 In retrospect, this model of integration remains suitable when the software
 entities in the integrated system are relatively few, and/or the interactions
 are simple.
 It is in cases when there are many entities, which need to interact in
 multiple ways and in particular sequences, e.g.
 when the interactions are stateful, that the system's requisite topological
 complexity can become onerous.
 
\end_layout

\begin_layout Subsection
Event-Driven Architecture and the hub-and-spoke pattern
\end_layout

\begin_layout Standard
One notable alternative architectural approach that serves to address the
 downsides of the P2P model first came to prominence as the hub-and-spoke
 pattern.
 Based on the concept of 
\begin_inset Quotes eld
\end_inset

events
\begin_inset Quotes erd
\end_inset

, this system is built around a 
\begin_inset Quotes eld
\end_inset

hub
\begin_inset Quotes erd
\end_inset

, that serves as the common target for the systems on either side, each
 assuming the role of either a 
\begin_inset Quotes eld
\end_inset

producer
\begin_inset Quotes erd
\end_inset

, or a 
\begin_inset Quotes eld
\end_inset

consumer
\begin_inset Quotes erd
\end_inset

 of events.
 In the simplest implementation of the hub, which makes no provision for
 central orchestration of the events in transit, the hub's role is described
 as that of an 
\begin_inset Quotes eld
\end_inset

event broker
\begin_inset Quotes erd
\end_inset

.
 the communication is multicast, with each event produced being 
\begin_inset Quotes eld
\end_inset

published
\begin_inset Quotes erd
\end_inset

 to the broker, and received by all consumers who have 
\begin_inset Quotes eld
\end_inset

subscribed
\begin_inset Quotes erd
\end_inset

 for receiving this event.
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename assets/broker.png
	scale 50
	BoundingBox 0bp 0bp 801bp 517bp

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
EDA, Broker topology
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In a somewhat different topology, that requires a more complex hub implementatio
n, the hub is meant to act as an 
\begin_inset Quotes eld
\end_inset

event mediator
\begin_inset Quotes erd
\end_inset

, centrally maintaining state regarding the event notifications.
 This positions the hub as the programmable orchestrator of the communication
 between systems, making more complex interactions possible and enabling
 it to act as a 
\begin_inset Quotes eld
\end_inset

load balancer
\begin_inset Quotes erd
\end_inset

, by allowing event notifications to be directed towards exactly one consumer,
 and to be kept to be resent in case there is no consumer available (
\begin_inset Quotes eld
\end_inset

event queue
\begin_inset Quotes erd
\end_inset

).
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename assets/mediator.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
EDA, Mediator topology
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The above variations of the same pattern, utilize, as they may, different
 semantics to describe their operation, evident in the terminology-laden
 paragraph above, they do nevertheless share a set of essential characteristics
 to differentiate them from the previously mentioned point-to-point pattern:
\end_layout

\begin_layout Itemize
Multicast communication: Each event can have more than one possible recipient-su
bscriber.
\end_layout

\begin_layout Itemize
Asynchronous communication: The publisher does not wait for a subscriber
 to process an event before sending a new event notification.
 Also called 
\begin_inset Quotes eld
\end_inset

fire-and-forget
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Itemize
Loose coupling: Event publishers are not aware of how many, if any, subscribers
 to the event there are, nor are they informed of how any particular event's
 processing proceeds.
 Publishers may still be built to facilitate a stateful sequence of events,
 though it is often preferable for such sequences to be mediated centrally,
 by the hub, rather than by the participating applications.
\begin_inset CommandInset citation
LatexCommand cite
key "key-10"
literal "false"

\end_inset


\end_layout

\begin_layout Itemize
Ontology: Event-driven systems commonly adopt a system-wide convention for
 prioritization and grouping of events.
 This allows subscribers to subscribe to entire categories of events or
 events that fall at some particular point in the hierarchical sequence
 of events regulating a business process.
 To indicate the distinction, subscribers are properly said to subscribe
 to 
\begin_inset Quotes eld
\end_inset

topics
\begin_inset Quotes erd
\end_inset

, which can correspond to either particular events or categories thereof.
\begin_inset CommandInset citation
LatexCommand cite
key "key-4"
literal "false"

\end_inset


\begin_inset Newline newline
\end_inset

A further point to be made on this property of hub-and-spoke, and event-driven
 architectures in general, is that ontologies produce what is called 
\begin_inset Quotes eld
\end_inset

semantic coupling
\begin_inset Quotes erd
\end_inset

.
 Event groups or hierarchies are only meaningful within the context of a
 system adopting the particular ontology within which they are represented.
 This makes communication between systems implemented with different ontologies
 impossible, unless an intermediate semantic matching technique is employed.
 Research is currently active in this area.
\begin_inset CommandInset citation
LatexCommand cite
key "key-11"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Event-driven architecture is properly constituted of subscribers that are
 both stateless and context-free.
 Each event notification ought to contain just enough details to enable
 the event handlers
\begin_inset Foot
status open

\begin_layout Plain Layout
alt.
 subscribers
\end_layout

\end_inset

 to guide the business flow in the intended direction e.g.
 by selecting among running one of several stateless, functionally autonomous
 modules, that may or may not be event emitters
\begin_inset Foot
status open

\begin_layout Plain Layout
alt.
 publishers
\end_layout

\end_inset

 themselves, or halting.
 
\end_layout

\begin_layout Standard
Event notifications should not provide any additional context.
 Also, the behavior they trigger should not depend in any way on the in-memory
 session state of the receiving applications.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
All things considered, the Event-driven Architecture paradigm, confer as
 it may several benefits over the point–to-point model in integrations of
 scale, is nevertheless ill-suited to certain specifications commonly required
 of enterprise systems.
 
\end_layout

\begin_layout Standard
First of all, the ability to chain hierarchical interactions between modules,
 is only possible through defining routing rules at the event mediator.
 While the convenience aspect of this method due to the centralization of
 the more complex parts of the system is not to be discounted, the degree
 of control over such interactions, in particular with regards to Quality
 of Service considerations such as time-sensitivity, reliability etc is
 rather low.
 
\end_layout

\begin_layout Standard
Also, event mediation adoption comes at the price of relatively tight coupling
 between the prospective event handlers and the mediation-capable hub.
 
\end_layout

\begin_layout Standard
Ultimately, event mediation can be an appropriate solution for a number
 of special cases in the context of loosely-coupled IT infrastructure mirroring
 diffuse business process environments, but is far from a satisfactory way
 to handle vertical interactions among functionally autonomous modules.
\end_layout

\begin_layout Standard
For the reasons referenced above, event-driven systems, while highly performant,
 are not suitable ways to integrate applications with time-sensitive interaction
s, e.g.
 Human-Computer Interfaces in banking applications.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
It is also a point worth making separately, that provisions for reliability
 such as delivery acknowledgement, transaction atomicity, security etc are
 formally unsuited to EDA systems' design, and ad-hoc interventions towards
 these ends can diminish EDA's inherent benefits.
\end_layout

\begin_layout Standard
Finally, the asynchronicity of EDA systems makes them more complex and harder
 to test, owing to the introduction of event communication infrastructure
 such as the hub and event channel implementations, and the non-deterministic
 nature of parallel computation.
\begin_inset CommandInset citation
LatexCommand cite
key "key-4,key-3"
literal "false"

\end_inset


\end_layout

\begin_layout Subsection
Service Oriented architecture and the Enterprise Service Bus
\end_layout

\begin_layout Standard
A synchronous architecture meant to address the point-to-point paradigm's
 numerous drawbacks in terms of technical debt accretion, agility and complexity
, while factoring in reliability provisions, is referred to as Service-Oriented
 Architecture, SOA for short.
\end_layout

\begin_layout Standard
Service Oriented Architecture is an evolution of predecessors such as component-
based architecture and Object Oriented Analysis and Design of remote objects
 e.g.
 the CORBA standard.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename assets/component-based architecture.png
	scale 50
	BoundingBox -80bp 0bp 533bp 391bp

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Component-based, point-to-point architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Component-based architecture emphasizes separation of concerns with respect
 to the various functions provided in a given software system.
 Components are commonly implemented around interfaces, that encapsulate
 the particulars of the components' implementation, and narrow the available
 surface-area for wiring together the various functionally autonomous modules.
 Cohesion is maintained by fitting additional modules onto the interfaces.
 The modules, which can be of arbitrary origin, are rendered into components
 by implementing their respective interfaces.
 The modules can exist as components locally within the same virtual or
 physical machine, or in the context of distributed systems such as networks
 (e.g.
 as web services or web resources).
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
In the SOA evolution of this approach, reusability and use in the context
 of distributed systems is emphasised.
 To realize this architectural style's potential, the promulgation of Web
 Service standards becomes instrumental.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
The effort towards this end has borne results through the W3C Web Services
 specification, though nowadays the emergence of alternatives and the REST
 architectural style in particular has created a rift in the SOA ecosystem,
 whose bridging is often handled by integration middleware.
\end_layout

\end_inset

 In this way it is ensured that networked software components can be developed
 as generic 
\begin_inset Quotes eld
\end_inset

Web Services
\begin_inset Quotes erd
\end_inset

, or business function-specific components that are implemented without
 knowledge or regard for the multitude of systems in which they may become
 involved.
\end_layout

\begin_layout Standard
Based on this, SOA can be defined as an architectural style focused around
 designing a system as a dynamic collection of services capable of communicating
 with one another.
 If the conventions are observed dilligently, the need for an EAI hub and
 it's accompanying module-specific connectors, database drivers and protocol
 adapters is theoretically obviated.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The Enterprise Service Bus (ESB) is the architectural feature of SOA systems
 enabling communication in a special variant of the more general client-server
 model, wherein any which service may behave as server or client.
 Universal availability and statelessness, both criteria met by proper services,
 but not by traditional server-client component couples, are prerequisites
 for the establishment of such as system.
\begin_inset CommandInset citation
LatexCommand cite
key "key-4"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
The ESB is equivalent to the 
\begin_inset Quotes eld
\end_inset

bus
\begin_inset Quotes erd
\end_inset

 design concept found in computer hardware architecture, in this case used
 to refer to the technological infrastructure used to implement a model
 for communication among independent, non-context aware software services
 running within networks of disparate and independent computers.
 
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename assets/generic soa.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Generic SOA
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
When working with more modern enterprise systems, which provide a Web Service-ab
iding API interface, implementing the ESB pattern amounts to providing certain
 service management capabilities, such as a means of controlled exposure
 of said APIs, using an exposure gateway service.
 
\end_layout

\begin_layout Standard
The primary aim of service management is to facilitate service discovery
 and exposure via a database called a Service Registry
\begin_inset CommandInset citation
LatexCommand cite
key "key-13"
literal "false"

\end_inset

 - in this particular scenario, it's function being partly substituted by
 the gateway - and an HTTP-accessible querying API.
 Reliance on human-maintained interface documentation e.g.
 Swagger or human-to-human interaction has proven a brittle strategy that
 erodes reusability, which, it is to be noted, is regarded as one of the
 main advantages of SOA.
 
\end_layout

\begin_layout Standard
More complete service management solutions deal with additional aspects,
 namely service negotiation i.e.
 the ability to set up a communication contract/connection with services,
 implementation of a security model with patterns for access control, e.g.
 with user roles/permission schemes, traffic control, encryption/redaction
 etc.
 Supplemental features can comprise configurable web portals that may describe
 the available APIs, enable potential users to issue keys automatically
 (self-subscribe) in order to use the APIs, provision analytics for both
 users and providers of the APIs, etc.
 
\end_layout

\begin_layout Standard
In systems requiring advanced service management capabilities, the related
 functions are commonly relegated to a separate database runtime known only
 to the gateway, introduced earlier as the Service Registry.
 Furthermore, in more complex integration scenarios, such as when unusual
 protocols or data formats are utilized, when compositions of multiple requests
 are called for, or perhaps in cases where transactionality needs to be
 implemented, the introduction of an integration engine existing as a separate
 runtime is, again, expedient.
 This hub-like arrangement is only one, albeit very common, of many possible
 topologies that are in accordance with the loose definition of ESB given
 above.
\end_layout

\begin_layout Standard
Even so, the term 
\begin_inset Quotes eld
\end_inset

ESB
\begin_inset Quotes erd
\end_inset

 has de facto come to refer to integration engine solutions adopting the
 architectural approach of a hub, often federated, whose main purpose is
 to facilitate a message-based communication model (termed Enterprise Message
 System, EMS) to be used within a particular SOA system's context.
 Such integration engines commonly provide auxillary capabilities, which
 were found to be essential additions for constructing more complex systems
 in the service-oriented style.
 They commonly contain logic for the encapsulation of legacy formats, protocols
 (or informal specs) and APIs of the integrated applications into an EMS
 compatible format, incorporate a service registry, and sport numerous other
 features for message routing, mediation, transformation, enrichment, validation
 etc.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
A summary of the archetypal SOA model's features in axes of comparison common
 with those of the aforementioned point-to-point and event-driven architectures
 could thus be:
\end_layout

\begin_layout Itemize
Unicast communication: Communication is established in provider-consumer
 pairs.
\end_layout

\begin_layout Itemize
Synchronous communication: A service consumer invokes a service provider
 through the network and has to wait until the completion of the operation
 on the provider's side, upon which a response is returned.
\end_layout

\begin_layout Itemize
Reusability/Interoperability: Services within a particular SOA context are
 defined by standardized service contracts, which include the interface,
 the schema, the communication protocol and various Quality of Service (QoS)
\begin_inset Foot
status open

\begin_layout Plain Layout
Quality of Service refers to the performance of a network service in multiple
 areas that commonly include scalability, security, reliability, lossyness,
 delay etc.
\end_layout

\end_inset

 policies.
 Each service can have multiple contracts, aimed at supporting different
 consumers.
 While these requirements result in tight coupling of services to the particular
 SOA context, reusability and interoperability among contract-abiding services
 is high, and further increased through the introduction of a service registry
 to facilitate discovery and exposure.
\end_layout

\begin_layout Itemize
Domain-driven design: Loose internal coupling allows Domain-driven design
 to be observed for a SOA system's constituent services.
 It's central idea is the creation of a Ubiquitous Language with the assistance
 of domain experts, that embeds domain terminology into the software components'
 naming and structure.
 This practice is claimed reduce friction in the operations side and increase
 maintainability and creative cross-domain collaboration.
\end_layout

\begin_layout Itemize
Business-centeredness: While many components within a SOA context may be
 developed in such a way as to constitute candidate services, only a subset
 of those have their service description exported, and perhaps published
 to a service registry, if there is one.
 Exposure in a controlled way is ensured via the provision of a fitness-for-purp
ose, or 
\begin_inset Quotes eld
\end_inset

litmus test
\begin_inset Quotes erd
\end_inset

, that determines whether a given service implementation meets certain business
 alignment, composability, reusability and technical feasibility criteria.
\begin_inset CommandInset citation
LatexCommand cite
key "key-14"
literal "false"

\end_inset

 This is facilitated greatly by the existence of accompanying service contracts,
 that allow the evaluation of the service's technical characteristics to
 remain separate from considerations concerning it's internal design.
\end_layout

\begin_layout Standard
In simpler scenarios, SOA systems are designed around a synchronous ESB,
 a property derived from the synchronous nature of their constituent services.
 A common approach is that of the service-oriented API gateway pattern,
 touched upon briefly in a previous section.
 It refers to business-coupled deployments consisting of components wrapped
 as Web Services, which are configured as to delegate service management
 to the system's gateway service.
 This service is charged with receiving requests from it's external API,
 accessible to clients outside the SOA system, aggregating the various services
 required to fulfill them, and returning the response in a synchronous manner.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Subsection
SOA 2.0
\end_layout

\begin_layout Standard
While taking an antidiametrical approach to communication with regards to
 EDA (pull vs push - soliciting a response as opposed to publishing an event
 notification), thus evading many of it's shortfalls, SOA, in practice,
 has come to serve as a useful complement in many EDA-stuctured enterprise
 systems, with services commonly being wrapped as components triggered by
 event handlers.
 
\end_layout

\begin_layout Standard
For most applications, communication then has to be framed within an Enterprise
 Messaging System that enables information flow and routing through event-driven
 infrastructure, and into synchronous services.
 
\end_layout

\begin_layout Standard
The popularity of such hybrid systems, combined with the aforementioned
 benefits of dedicated SOA integration engines, has brought about a state
 of affairs where most productized ESB implementations have come to rely
 on distributed, message-oriented middleware, dubbed 
\begin_inset Quotes eld
\end_inset

ESBs
\begin_inset Quotes erd
\end_inset

, introducing a federated hub and event-driven messaging infrastructure
 as ubiquitous features of present-day SOA systems.
\begin_inset CommandInset citation
LatexCommand cite
key "key-4"
literal "false"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
placement ph
wide false
sideways true
status collapsed

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename assets/event-driven soa.png
	scale 50

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Event-driven SOA (SOA 2.0)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
This model of SOA has been called next-generation SOA, or 
\begin_inset Quotes eld
\end_inset

SOA 2.0
\begin_inset Quotes erd
\end_inset

.
 To elucidate the cause of the wide popularity of this hybrid, a pros-and-cons
 comparison of the two styles will be attempted.
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Traditional SOA can be advantageous for:
\end_layout

\begin_layout Itemize
Service chaining: Operations that involve interaction between vertical hierarchi
cal layers of functions packaged as services are common.
 The request-response model of communication, supplemented by polling mechanisms
 for interactions involving more than two services, ensures the interactions
 are performed in the correct order.
 The implementation of such chains is further simplified by the assured
 existence of contracts that specify the Quality-of-Service aspects of the
 modules involved.
\end_layout

\begin_layout Itemize
Human-Computer Interaction and other time-sensitive processes: The synchronous
 and contract-bound nature of communication is expedient for the design
 of real-time services, such as the decision-enablement and actuation capabiliti
es that are expected from modern enteprise systems.
\end_layout

\begin_layout Itemize
Transactionality: Interaction between service pairs can be said to implement
 
\begin_inset Quotes eld
\end_inset

pull
\begin_inset Quotes erd
\end_inset

 semantics.
 Information like response status codes can be propagated back down the
 call stack, through service chains of arbitrary depth, until the original
 service consumer receives their response.
 Mechanisms relying on this property can be put in place to guarantee transactio
n atomicity
\begin_inset Foot
status open

\begin_layout Plain Layout
Either all interactions occur successfully or no interaction occurs.
 
\end_layout

\end_inset

 .
\end_layout

\begin_layout Itemize
Testing: Synchronicity makes contract specification possible, and contract-speci
fied policy boundaries increase the tractability of operations involving
 multiple services..
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
On the con side of SOA, it could be noted that, despite the the high internal
 interoperability of systems designed in this manner, interfacing with external
 systems remains hard, as they would have to be wrapped as services abiding
 to the particular ESB setup, and establish connections bound to service-contrac
ts composed often under unaccommodating assumptions.
\begin_inset Newpage pagebreak
\end_inset


\begin_inset Newline newline
\end_inset

Meanwhile, EDA exhibits it's own set of advantages in multiple areas:
\end_layout

\begin_layout Itemize
Business-to-business (B2B) integration: EDA implements 
\begin_inset Quotes eld
\end_inset

push
\begin_inset Quotes erd
\end_inset

 semantics.
 An event emitter's active involvement in communication ends once it publishes
 an event notification.
 Control of an operation's flow is shifted away from the event source, being
 distributed/delegated to event handlers.
 An enterprise partner can integrate with a preexisting EDA system with
 relative ease, by encapsulating their system's components as event emitters
 that conform to the system's particular event semantics.
 In case a partner already utilizes their own EDA system, a semantic matching
 solution can alternatively serve to directly bridge the two systems.
\end_layout

\begin_layout Itemize
Business workflow and other arbitrarily-halting processes: Many business
 processes involve human input in their workflow.
 A Warehouse Management System (WMS), for example, has to be updated with
 the status of the physical warehouse by warehouse employees, before moving
 forward with the processing of an inventory receipt.
 As EDA is asynchronous and contract-free by design, it enables such operations
 to be readily embeddable within an Enterprise Software-driven workflow.
\end_layout

\begin_layout Itemize
Ease of deployment: The EDA pattern is characterized by loose coupling which
 allows independent deployment and unhindered horizontal scalability, as
 there are no dependencies among the participating components.
 For solutions that require maximum ease of deployment, event broker topology
 is a better option than event mediator topology.
 This is due to the fact that in the event mediator topology, relatively
 tight event mediator - event handler coupling can exist .
\end_layout

\begin_layout Itemize
Performance: Asynchronicity makes data parallelism via multi-core processing
 possible
\end_layout

\begin_layout Itemize
Scalability: The above two points together, are essential elements for systems
 envisioned to be scalable.
\end_layout

\begin_layout Standard
On the con side, EDA system testing is not easy due to the asynchronous
 nature of the processing, and the concommitant lack of service contracts.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The introduction of an event-driven, message-oriented middleware at the
 core of a SOA-inspired system increases the base complexity of the design,
 but can, in theory, result in a SOA-EDA hybrid bestowed with advantages
 from both approaches while eliminating their respective drawbacks.
 A resulting system would benefit from a performant, loosely coupled, event-driv
en architecture, with a design amenable to Business-to-business connections
 and hybridizable with SOAs encapsulated as event emission-capable services
 triggered by event-handlers.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Though there's still the semantic coupling issue and APIs rule the world
 now.
 but apis are not SOA-conforming services either (e.g.
 ignore Service statelessness principle).
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

The application of this pattern helps to further decouple the service consumers
 from the service providers and increases the overall reliability of a service
 composition.
 
\begin_inset Quotes erd
\end_inset

 wp Event-driven Messaging
\begin_inset Newline newline
\end_inset

SOA 2.0 archpatbook p28
\begin_inset Newline newline
\end_inset

(
\begin_inset Quotes eld
\end_inset

The benefits of atomic service transactions are as follows: Helps to propagate
 the rollback mechanism across message-based business services Effective
 implementation of the stateless principle
\begin_inset Quotes erd
\end_inset

 archpatbook p215)
\begin_inset Newline newline
\end_inset

( eipbook p73, opengroup.org 
\begin_inset Quotes eld
\end_inset

Having a central mechanism by which all messages are exchanged facilitates
 monitoring, control, transformation, and security of messages.
\begin_inset Quotes erd
\end_inset

 but why use messages/ asynchronous EDA features in soa in the first place?
 perhaps keep them separate for now, or make the distinction clear.)
\end_layout

\begin_layout Plain Layout
Loose coupling is achieved through transactions, queues provided by message-orie
nted middleware, and interoperability standards.
\end_layout

\begin_layout Plain Layout
Transactions help ensure validity of exchanges, queues enable asynchronicity
 and load balancing in distributed systems, and interoperability standards
 provide a common target for the integration of legacy systems (often rendering
 them network-enabled in the process) and newly implemented services alike.
\end_layout

\begin_layout Plain Layout
In the messaging approach, provisions for asynchronicity (message buffers,
 brokers) and arbitrary consumer scaling are taken.
\end_layout

\begin_layout Plain Layout
Domain-Specific-Languages and Aspect-Oriented Programming can be used to
 manage the complexity produced by the increased need for isolation and
 encapsulation that Domain-Driven design necessitates.
\end_layout

\begin_layout Plain Layout
Microservices is a novel, implementation agnostic approach to SOA, that
 allows for domain-driven design to be observed (actually they are only
 loosely related and, in fact, operate at different scopes, as discussed
 here
\end_layout

\begin_layout Plain Layout
https://www.ibm.com/cloud/learn/soa)
\end_layout

\begin_layout Plain Layout
https://en.wikipedia.org/wiki/Service-oriented_architecture#Microservices
\end_layout

\begin_layout Plain Layout
(archpat p238 soa vs eda and b2b)
\end_layout

\begin_layout Plain Layout
there does exist async request-response, but is beyond the soa convention
\end_layout

\begin_layout Plain Layout
integration engines of today allow for the implementation of different patterns
 that are more lightweight and decentralized.
 no longer is runtime cloning of the entire integration engine required
 for scaling infrastructure, nor is there hard need for a dedicated team
 with deep expertise in the particular SOA solution.
 how this is achieved:
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

The introduction of an API management layer led to the obvious question:
 What now is the ESB? Many had come to see the integration runtime and the
 ESB pattern as one and the same.
 But in fact, if the ESB pattern is all about exposing services and APIs,
 then the boundaries of the pattern really include both the integration
 runtime and the exposure gateway, and in some cases just the gateway.
 However, due to the ESB's incorrect association with the integration runtime,
 we have to accept that this is not how the ESB term is typically used.
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

back-end-for-front-end (BFF) pattern (present in mobile apps/ SPAs) was
 the first foray outside enterprise: APIs perfectly suited to the needs
 of a prospective frontend, with rationalized data models, ideal granularity
 of operations, specialized security models etc.
 This developer-orientation also marked a wholesale departure from the idea
 of achieving API reusability through stability, a development that goes
 hand in hand with a bigger investment in API management to lower the maintenanc
e overhead this new stance would entail.
\end_layout

\begin_layout Plain Layout
Modern API management solutions create APIs via configuration rather than
 coding, and the task of creating or changing an API usually takes only
 minutes.
 The nature of an easily managed API is simply that it is both defined and
 controlled by configuration.
 API management solutions, while complex in their implementation and often
 costly as proprietary offerings, render the maintenance of non-stable consumer-
oriented APIs practical.
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout
APIs are always designed to be attractive to the intended consumer, and
 they change as the needs of the consumer change.
 Services, in contrast, are generally designed with global cost and stability
 as the most important concerns.
 In the car analogy, the API is the race car designed for looks and consumption,
 but the service is the regular car designed for cost and mass production.
\end_layout

\begin_layout Plain Layout
, a mobile developer just wants it to be simple for her particular app.
 On the other side, the back-end team wants everyone to use the same standardize
d service and data model.
\end_layout

\begin_layout Plain Layout
APIs are controlled (proxy) views of the data and capabilities of a domain,
 optimized for the needs of API consumers.
 As long as it’s dirt cheap to create and maintain proxy APIs, you can use
 them to render a domain in multiple forms, optimized for each group of
 API consumers.
 (After all, you probably want to give external partners a different view
 of your capabilities from the view your internal developers have
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

SOA emerged as a means of shielding service consumers from changes in the
 back end.
 But who protects the service providers from the churn of changing needs
 in omni-channel front-end solutions?
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
Services are the means by which providers codify the base capabilities of
 their domains.
 APIs are the way in which those capabilities (services) are repackaged,
 productized, and shared in an easy-to-use form
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
from then on, public exposure of partner APIs has steadily become more common,
 providing the opportunity for collaboration among loosely related parties.
 The resultant market-like ecosystem has been dubbed the 
\begin_inset Quotes eld
\end_inset

API Economy
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsection
The API economy
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

lightweight and decentralized.
 no longer is runtime cloning of the entire integration engine required
 for scaling infrastructure,
\begin_inset Quotes erd
\end_inset

 and integration can be performed wihout 
\begin_inset Quotes eld
\end_inset

hard need for a dedicated team with deep expertise in the particular SOA
 solution
\begin_inset Quotes erd
\end_inset

.
 APIs are no longer archaic hieroglyphs exposed by monolithic cobweb-ridden
 integration runtimes, left to accrue technical debt, they are part of outward
 facing platform offerings (API productization), that along with the -necessary
 to reduce maintenance complexity in todays's Agile software delivery model
 - API management capabilities, are core to the business strategy of many
 enterprises instead.
 orchestrated microservices and consumer-oriented partner APIs aimed at
 3d party developers are the enablers of today's API economy.
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout
The API economy emerges when APIs become part of the business model.
 Public and partner APIs have been strategic enablers for sev- eral online
 business models.
 For example, Twitter APIs easily have ten times more traffic than the Twitter
 website does.
 The com- pany’s business model deliberately focuses on Tweet mediation,
 letting anyone who wants to do so provide the end-user experience.
 CHAPTER 1 Introducing APIs 7 These materials are © 2018 John Wiley & Sons,
 Inc.
 Any dissemination, distribution, or unauthorized use is strictly prohibited.Anot
her example, Amazon, from the get-go, chose to be not only just an Internet
 retailer but also a ubiquitous merchant portal.
 Amazon’s merchant platform is deliberately built on APIs that allow easy
 onboarding of new merchants.
 APIs as business network enablers aren’t new.
 Banks have built payment infrastructures and clearinghouses based on well-defin
ed APIs for decades.
 Modern APIs, however, are built explicitly for an open ecosystem (internal
 or external), not for closed private net- works.
 Furthermore, the consumption models for APIs are standardized with a focus
 on ease of consumption rather than ease of creation.
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset


\end_layout

\begin_layout Plain Layout
TODO MENTION paypal, stripe as examples of API productization, Uber as example
 of basing a business on partner APIs
\end_layout

\begin_layout Plain Layout
API layers (mentioned in us-fsi-api-economy.pdf): APIs exposed to accelerate
 new service development built upon them
\end_layout

\begin_layout Plain Layout
The emergence of this last developmental trend arguably does credit to the
 promise of reusability the idea of web service orientation has borne since
 it's inception.
 TODO democratisation of industry, heightened pace of disruption (CITE forbes
 article)
\end_layout

\begin_layout Plain Layout
TODO SaaS perhaps deserves a mention here
\end_layout

\begin_layout Plain Layout
TODO check esiarchapproach As a technology, EAI typically refers to non-intrusiv
e application integration techniques aimed at creating loosely coupled enterpris
e software systems.
 Message brokers, adapters, process automation tools, and similar modern
 products are hallmarks of the EAI technology.
\end_layout

\begin_layout Plain Layout
)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Messaging in practice: Message Oriented Middleware
\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

The Java EE programming environment provides a standard API called JMS (Java
 Message Service), which is implemented by most MOM vendors and aims to
 hide the particular MOM API implementations; however, JMS does not define
 the format of the messages that are exchanged, so JMS systems are not interoper
able.
\begin_inset Quotes erd
\end_inset

 (semantic coupling)
\end_layout

\begin_layout Plain Layout
(TODO EIPBook p72 on why messaging)
\end_layout

\begin_layout Plain Layout
(TODO read EIPbook forewords on SOA, asynchronous messaging of self reliant
 systems being the point of integrated systems as opposed to n-tier codependent
 distributed systems, conferring benefits of request throttling and load
 balancing but increasing complexity; this fact makes asynchronous messaging
 a promising approach, and this has informed the direction of this thesis)
\end_layout

\begin_layout Plain Layout
(TODO SOA is enabled via messaging.
 Time to get deep into it)
\end_layout

\begin_layout Plain Layout
(
\begin_inset Quotes eld
\end_inset

The message queue paradigm is a sibling of the publisher/subscriber pattern
\begin_inset Quotes erd
\end_inset

 CITE wp Message Queue)
\end_layout

\begin_layout Plain Layout
Examples from Java OOP, JMS messaging, Camel.
\end_layout

\begin_layout Itemize
Common architectural elements of MOM systems (request databases/message
 buffers, aggregators, api consumers, services).
 
\end_layout

\begin_layout Itemize
Intruduction to messaging, key problems it solves (separation of concerns,
 decoupling etc; use analogues from different domains e.g.
 URI barcodes etc) Identifier vs Locator disambiguation
\end_layout

\begin_layout Plain Layout
Message passing implies URLs (Uniform Locator of Resources) Uniform Identifier:
 as in URI: 23-digit barcode form unique id of a thing whose location or
 mode of access is not defined plus Resource Locator: 
\end_layout

\begin_layout Plain Layout
-Locator as in http:// (mode of access) which implies the rest is an address.
 
\end_layout

\begin_layout Plain Layout
-Resource as in shared-nothing, volatile object: Evoke the same operation
 (e.g INSERT) twice, don't expect it to be the same function call because
 the message-passing abstraction hides (therefore isolates) underlying state
 changes.
 
\end_layout

\begin_layout Plain Layout
Eg.
 a necessary rerouting of a request because a node is down does not concern
 the message sender.
 Drawing out the metaphor, URI = class interface, URL = address of volatile
 object 
\end_layout

\begin_layout Itemize
Message buffer considerations: When full: - Block the sender (deadlock risk)
 - Drop future messages (producer-consumer problem; unreliability), Asynchronici
ty and concurrency: gotta have both! + friends
\end_layout

\begin_layout Itemize
Services as components of monoliths vs distributed systems.
 Messaging in OOP vs JMS topic, queue schema.
 Compare and contrast, justify differences by comparing problem domains.
\end_layout

\begin_deeper
\begin_layout Plain Layout
Pros: Shared--nothing, all the loose-coupling stuff 
\end_layout

\begin_layout Plain Layout
Cons: overhead as arguments need to be copied and transmitted to the receiving
 object 
\end_layout

\begin_layout Itemize
https://en.wikipedia.org/wiki/Message_passing#Distributed_objects
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

In Camel, DSL means a fluent Java API that contains methods named for EIP
 terms.
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Quotes eld
\end_inset

Camel isn’t an enterprise service bus (ESB
\begin_inset Quotes erd
\end_inset

 ( CITE camelia p102)
\begin_inset Newline newline
\end_inset

(TODO eipbook p51 a Composed Message Processor is the combination of a Splitter,
 a Router and an aggregator.
 A router is a Camel Route, a thing that takes in an event notification
 (from() and decides what service-server to invoke dynamically.
 a router is therefore at once an EDA decoupler (an event handler), and
 a chainer for SOA compliant message-interfaced services (with url() for
 web services, being wrapped automatically by camel into message interfaces,
 or with 
\begin_inset Quotes eld
\end_inset

processor
\begin_inset Quotes erd
\end_inset

 (CITE camelia p133) wrappers: esb-style connectors, a away to wrap multiple
 generic java components into message-interfaced SOA-services.
\end_layout

\begin_layout Plain Layout
so camel routes expose event handler routing logic, see camelia p131
\end_layout

\begin_layout Plain Layout
a camel route is fire-and-forget if eg the timer event causes no message
 to finally exit the route, the event handler run is just ineffectual)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

Server as persistence hub, interacting with client services via library
 calls with 
\begin_inset Quotes eld
\end_inset

direct:
\begin_inset Quotes erd
\end_inset

 route chaining.
\end_layout

\begin_layout Itemize
Split, choice and aggregator branching and joining.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

from:
\begin_inset Quotes erd
\end_inset

-driven abstract pollers with different implementations per instance.
 How can Camel help adapt towards a more scalable microservice variant?
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Plain Layout
Multiple task scheduling components are available.
 They produce timer events that can be used to trigger recurring camel routes
 via consumer EIPs, or otherwise provide a means of time tracking for local
 or distributed tasks.
 The primary ones are scheduler (or it's simpler variant, timer) and quartz.
 
\end_layout

\begin_layout Plain Layout
The scheduler component utilizes the host jdk's timer and is intended for
 locally tracked tasks that have no need for accuracy, as no provision is
 made against downtime.
\end_layout

\begin_layout Plain Layout
The quartz component uses a database to store timer events and supports
 distributed timers, and is therefore fault tolerant and suitable for scheduling
 distributed tasks.
\end_layout

\begin_layout Subsection*
declarative DSLs/xml
\end_layout

\begin_layout Plain Layout
(TODO https://martinfowler.com/dsl.html )
\end_layout

\begin_layout Plain Layout
Examples from declarative vs procedural DSLs (e.g.
 shell vs guile scripts), Spring traditional remoting vs Camel, timer/from
 components introduced here, as an example of how Camel departs from older
 integration methods..
\end_layout

\begin_layout Itemize
Producer, consumer properties per component.
\end_layout

\begin_layout Itemize
Seamless remoting via 
\begin_inset Quotes eld
\end_inset

.to()
\begin_inset Quotes erd
\end_inset

 chaining.
 Direct ProducerTemplate calls.
\end_layout

\begin_layout Itemize
Declarative programming advantages, mention drag-and-drop services (e.g.
 redhat's integration product).
\end_layout

\begin_layout Itemize
Machine readable markup vs Camel's DSL hack.
\end_layout

\begin_layout Section
Apache Camel field study
\end_layout

\begin_layout Plain Layout
Examining a 3PL logistic company's middleware stack
\end_layout

\begin_layout Part
The Enterprise Integration Patterns (EIP) vocabulary
\end_layout

\begin_layout Plain Layout
TODO esiarchapproach p23 on essential EAI technologies
\end_layout

\begin_layout Plain Layout
TODO archpatbook p350 Intermediate routing pattern as an alternative to
 embedding routing logic in chained services
\end_layout

\begin_layout Subsection
Messaging
\end_layout

\begin_layout Plain Layout
TODO archpatbook p125
\end_layout

\begin_layout Plain Layout
Message (and exchange), pipes and filters, router, translator, endpoint
\end_layout

\begin_layout Subsubsection
Message channel
\end_layout

\begin_layout Plain Layout
point2point, publish-subscribe, channel adapter, message bus
\end_layout

\begin_layout Subsubsection
Router
\end_layout

\begin_layout Plain Layout
filter, splitter, aggregator, broker
\end_layout

\begin_layout Subsubsection
Message endpoint
\end_layout

\begin_layout Plain Layout
consumers: polling, event-driven, message dispatcher
\end_layout

\end_deeper
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Part
Apache Camel: a framework for constructing Message-Oriented Middleware
\end_layout

\begin_layout Standard
The convergence around hybrid SOA architectures and Enteprise Messaging
 Systems as the default type of communication model for enteprise integration
 brought into focus the need for a common, platform-independent language
 to describe the common capabilities and architectural features of such
 systems.
 The resulting vocabulary is what is referred to as 
\begin_inset Quotes eld
\end_inset

Enterprise Integration Patterns
\begin_inset Quotes erd
\end_inset

 (EIPs).
\begin_inset CommandInset citation
LatexCommand cite
key "key-15"
literal "false"

\end_inset


\end_layout

\begin_layout Standard
Apache Camel is a framework for building message-oriented middleware.
 More generally, it aspires to enable integrations designed around the Enterpris
e Integration Pattern (EIP) vocabulary.
 In addition to native support via JMS for ActiveMQ and other message brokers
 and infrastructure in the EDA paradigm, it provides features that enable
 most common SOA architectures, modern and legacy alike.
 Standard SOAP Web Services, RESTful http Web Services and more are natively
 supported, with Amazon Web Services, Graphql and other modern service-oriented
 technologies supported as extensions.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section
Basic Concepts
\end_layout

\begin_layout Standard
Arguably the most important aspect of Camel is message routing, which is
 utilized to enable SOA-style service composition within the context of
 an event-driven integration system.
\end_layout

\begin_layout Standard
A Camel route begins from a consumer endpoint, which corresponds either
 to an event handler passively receiving inbound messages published on a
 particular event topic, or to a polling function synchronously monitoring
 a particular source by fetching messages at scheduled intervals.
\end_layout

\begin_layout Standard
Components are batteries-included Camel factories for creating Endpoint
 instances.
 They contain the protocol-specific logic for obtaining information from
 outside sources and packaging it as inbound messages.
\end_layout

\begin_layout Standard
The inbound messages' carrier through the service chain representing a Camel
 route is called a message exchange.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename assets/camel exchange.png
	scale 70
	BoundingBox -60bp 0bp 361bp 340bp

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Camel Exchange
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are two types of Message Exchange Pattern (MEP).
 InOnly corresponds to operating as an event handler.
 The incoming Message is an event notification, being used in one-way communicat
ion where flow control is passed to the receiving module.
 InOut is a pattern used to emulate a SOA-style request-response interaction,
 and is useful for chaining local services with Web Services or other remote
 components.
\begin_inset Newline newline
\end_inset


\begin_inset Float figure
placement H
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Graphics
	filename assets/mepcamel.png
	scale 70

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Camel Route
\end_layout

\end_inset


\end_layout

\end_inset

The Camel Processor is the interface for incorporating custom logic, such
 as conventional system components or services, into a Camel route's exchange
 channel.
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Finally, by Camel's offering of a Domain Specific language, which is implemented
 simply as a Java API that contains methods named after EIP terms, an integrated
 system's Camel Routes are rendered into a prime leverage point for inspection
 and control of the logical flow of integration.
\begin_inset CommandInset citation
LatexCommand cite
key "key-1"
literal "false"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Section
Example of a Camel Route
\end_layout

\begin_layout Standard
We maintain the middleware stack of a logistics company.
 One of our integration solution's tasks is contacting the various couriers'
 APIs and issuing shipment vouchers for the goods that need to be delivered,
 then updating the company's ERP with this knowledge through an http callback.
 Open requests for issuing such vouchers are stored in a database.
 This is the Camel route in full:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 from("timer://$Voucher?period=500000&repeatCount=-1")             .log(LoggingLe
vel.INFO,logger,"Starting polling
\end_layout

\begin_layout Plain Layout

				for open voucher requests")            
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.setHeader('courierCode').constant(configuration.courierCode)             
\end_layout

\begin_layout Plain Layout

.to("sql:classpath:sql/openVoucher.sql")              
\end_layout

\begin_layout Plain Layout

.log(configuration.name +'Voucher: Processing ${body.size}
\end_layout

\begin_layout Plain Layout

				voucher requests')             
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

.setProperty('totalRequests').simple('${body.size}')             
\end_layout

\begin_layout Plain Layout

.split(body(),voucherAggregation)
\end_layout

\begin_layout Plain Layout

      .log(LoggingLevel.INFO,logger,'Posting for voucher
\end_layout

\begin_layout Plain Layout

				for request: ${body}')               
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

      .process("issueVoucherProcessor")                 
\end_layout

\begin_layout Plain Layout

      .filter().simple('${body.voucherCallbackUrl} != null')              
   
\end_layout

\begin_layout Plain Layout

            .process('voucherCallbackProcessor')                 
\end_layout

\begin_layout Plain Layout

      .end()             
\end_layout

\begin_layout Plain Layout

.end()             
\end_layout

\begin_layout Plain Layout

.log(LoggingLevel.INFO, logger, 'Successfully Updated 
\end_layout

\begin_layout Plain Layout

${property.successCount}/$ {property.totalRequests} requests')
\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
The Camel route below is a polling consumer firing periodically every 500000
 seconds, The timer component is used just for the purpose of triggering
 the start of an exchange, yielding an inbound message with an empty body:
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

 from("timer://$Voucher?period=500000&repeatCount=-1")             .log(LoggingLe
vel.INFO,logger,"Starting polling 
\end_layout

\begin_layout Plain Layout

				for open voucher requests")
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The empty message is wrapped in an exchange, which is propagated to the
 .to() Camel EIP.
 The .to() EIP is an endpoint that, unlike .from(), which acts only as a message
 consumer, is also capable of producing messages.
 In this case, it executes an sql script against a database whose address
 and credentials are stored in the system's configuration, and places the
 returned records in the exchange's outbound message's body:
\begin_inset Newline newline
\end_inset


\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.setHeader('courierCode').constant(configuration.courierCode)             
\end_layout

\begin_layout Plain Layout

.to("sql:classpath:sql/openVoucher.sql")      
\end_layout

\end_inset

The courierCode header value is injected into the sql query so as to draw
 open voucher records only for the specific courier.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
Next, the open voucher records are split, so that they may be consumed one
 by one by the issueVoucherProcessor.
 When the name of a Camel processor object is given as an argument to a
 .process() EIP, the processor's process() method is invoked.
 In our scenario, that method should be sending a POST request to a courier's
 API in order to receive the code of a new shipment voucher:
\begin_inset Newline newline
\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

.log(configuration.name +'Voucher: Processing ${body.size}
\end_layout

\begin_layout Plain Layout

					voucher requests')             
\end_layout

\begin_layout Plain Layout

.setProperty('totalRequests').simple('${body.size}')             
\end_layout

\begin_layout Plain Layout

.split(body(),voucherAggregation)
\end_layout

\begin_layout Plain Layout

      .log(LoggingLevel.INFO,logger,'Posting for voucher
\end_layout

\begin_layout Plain Layout

				for request: ${body}')                 
\end_layout

\begin_layout Plain Layout

      .process("issueVoucherProcessor")                 
\end_layout

\begin_layout Plain Layout

      .filter().simple('${body.voucherCallbackUrl} != null')              
   
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

            .process('voucherCallbackProcessor')                 
\end_layout

\begin_layout Plain Layout

      .end()             
\end_layout

\begin_layout Plain Layout

.end()             
\end_layout

\begin_layout Plain Layout

.log(LoggingLevel.INFO, logger, Successfully Updated
\end_layout

\begin_layout Plain Layout

${property.successCount}/${property.totalRequests} requests')
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "1pt"

\end_inset


\end_layout

\begin_layout Standard
A few more things are happening here.
 A callback is sent to the company's ERP via the voucherCallbackProcessor,
 to inform that a voucher has been issued.
 The relevant service is invoked only for those vouchers among the issued,
 who originally provided a callback url.
\begin_inset Newline newline
\end_inset

Finally, voucherAggregation is a function implementing the Aggregator EIP
 through the respective Camel interface.
 It's function is to run on each iteration of the .split() pattern.
 In this particular instance, it merely increments to the successCount property
 for each voucher successfully issued.
\end_layout

\begin_layout Standard
\begin_inset Newpage pagebreak
\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-6"

\end_inset

David A Chappell: Enterprise Service Bus.
 O'Reilly Media (2004)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-2"

\end_inset

Martin Fowler: Patterns of Enterprise Application Architecture.
 Addison-Wesley Professional (2002)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-9"
literal "false"

\end_inset

Alexandros Gazis, Eleftheria Katsiri: Middleware 101, What to know now and
 in the future.
 In: ACM Queue, vol.
 20 issue 1 (2022)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-11"

\end_inset

Souleiman Hasan, Sean O’Riain, Edward Curry: Approximate Semantic Matching
 of Heterogeneous Events.
 ACM International Conference on Distributed and Event‐based Systems, Berlin,
 Germany (2012)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-3"

\end_inset

Gregor Hohpe, Bobby Woolf: Enteprise Integration Patterns, pp.
 18, 32.
 Addison-Wesley Professional (2003)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-1"

\end_inset

Claus Ibsen, Jonathan Anstey: Camel in Action.
 Manning Publications (2008)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-5"

\end_inset

Pontus Johnson: Enterprise Software System Integration, An Architectural
 Perspective.
 Ph.D.
 thesis.
 Industrial Information and Control Systems KTH, Royal Institute of Technology,
 Stockholm, Sweden (2002)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-10"

\end_inset

Brenda M.
 Michelson: Event-Driven Architecture Overview.
 Patricia Seybold Group (2006)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-14"

\end_inset

Cécile Péraire, Mike Edwards, Angelo Fernandes, Enrico Mancin, Kathy Carroll:
 The IBM Rational Unified Process for System z, Service Specification.
 IBM Corporation (2007).
 URL 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://deg.egov.bg/LP/soa.rup_soma/tasks/soa_service_qualification_E0D920A6.html
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-4"

\end_inset

Harihara Subramanian Pethuru Raj, Anupama Raman: Architectural Patterns,
 pp.
 24, 25, 28, 210, 245.
 Packt Publishing (2017)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-8"

\end_inset

Bobby Woolf: Event-Driven Architecture and Service-Oriented Architecture.
 IBM Software Services for WebSphere, IBM Corporation (2006)
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-15"

\end_inset

Olaf Zimmermann, Cesare Pautasso, Gregor Hohpe, Bobby Woolf: A Decade of
 Enterprise Integration Patterns: A Conversation with the Authors, pp.
 13–19.
 IEEE Software, vol.
 33 issue 1 (2016) 
\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-7"

\end_inset

IBM Cloud Education: What is Middleware? (2022).
 URL 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.ibm.com/cloud/learn/middleware
\end_layout

\end_inset


\end_layout

\begin_layout Bibliography
\begin_inset CommandInset bibitem
LatexCommand bibitem
key "key-13"

\end_inset

Redhat Technology Topics: What is a Service Registry? (2021).
 URL 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

https://www.redhat.com/en/topics/integration/what-is-a-service-registry
\end_layout

\end_inset


\end_layout

\end_body
\end_document
